"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BankrunProvider = exports.startAnchor = void 0;
const web3_js_1 = require("@solana/web3.js");
const bs58_1 = __importDefault(require("bs58"));
const nodewallet_1 = __importDefault(require("@coral-xyz/anchor/dist/cjs/nodewallet"));
var solana_bankrun_1 = require("solana-bankrun");
Object.defineProperty(exports, "startAnchor", { enumerable: true, get: function () { return solana_bankrun_1.startAnchor; } });
class BankrunConnectionProxy {
    constructor(banksClient) {
        this.banksClient = banksClient;
    }
    async getAccountInfoAndContext(publicKey, commitmentOrConfig) {
        const accountInfoBytes = await this.banksClient.getAccount(publicKey);
        if (!accountInfoBytes)
            throw new Error(`Could not find ${publicKey.toBase58()}`);
        return {
            context: { slot: Number(await this.banksClient.getSlot()) },
            value: {
                ...accountInfoBytes,
                data: Buffer.from(accountInfoBytes.data),
            },
        };
    }
    async getAccountInfo(publicKey, commitmentOrConfig) {
        const accountInfoBytes = await this.banksClient.getAccount(publicKey);
        if (!accountInfoBytes)
            throw new Error(`Could not find ${publicKey.toBase58()}`);
        return {
            ...accountInfoBytes,
            data: Buffer.from(accountInfoBytes.data),
        };
    }
    async getMinimumBalanceForRentExemption(dataLength, commitment) {
        const rent = await this.banksClient.getRent();
        return Number(rent.minimumBalance(BigInt(dataLength)));
    }
}
async function sendWithErr(tx, client) {
    const res = await client.tryProcessTransaction(tx);
    const maybeMeta = res.meta;
    const errMsg = res.result;
    if (errMsg !== null) {
        if (maybeMeta !== null) {
            const logs = maybeMeta.logMessages;
            throw new web3_js_1.SendTransactionError({
                action: "send",
                signature: "",
                transactionMessage: errMsg,
                logs: logs,
            });
        }
        else {
            throw new web3_js_1.SendTransactionError({
                action: "send",
                signature: "",
                transactionMessage: errMsg,
                logs: [],
            });
        }
    }
}
class BankrunProvider {
    constructor(context, wallet) {
        this.context = context;
        this.wallet = wallet || new nodewallet_1.default(context.payer);
        this.connection = new BankrunConnectionProxy(context.banksClient); // uh
        this.publicKey = this.wallet.publicKey;
    }
    async send(tx, signers, opts) {
        if ("version" in tx) {
            signers?.forEach((signer) => tx.sign([signer]));
        }
        else {
            tx.feePayer = tx.feePayer ?? this.wallet.publicKey;
            tx.recentBlockhash = (await this.context.banksClient.getLatestBlockhash())[0];
            signers?.forEach((signer) => tx.partialSign(signer));
        }
        this.wallet.signTransaction(tx);
        let signature;
        if ("version" in tx) {
            signature = bs58_1.default.encode(tx.signatures[0]);
        }
        else {
            if (!tx.signature)
                throw new Error("Missing fee payer signature");
            signature = bs58_1.default.encode(tx.signature);
        }
        await this.context.banksClient.sendTransaction(tx);
        return signature;
    }
    async sendAndConfirm(tx, signers, opts) {
        if ("version" in tx) {
            signers?.forEach((signer) => tx.sign([signer]));
        }
        else {
            tx.feePayer = tx.feePayer ?? this.wallet.publicKey;
            tx.recentBlockhash = (await this.context.banksClient.getLatestBlockhash())[0];
            signers?.forEach((signer) => tx.partialSign(signer));
        }
        this.wallet.signTransaction(tx);
        let signature;
        if ("version" in tx) {
            signature = bs58_1.default.encode(tx.signatures[0]);
        }
        else {
            if (!tx.signature)
                throw new Error("Missing fee payer signature");
            signature = bs58_1.default.encode(tx.signature);
        }
        await sendWithErr(tx, this.context.banksClient);
        return signature;
    }
    async sendAll(txWithSigners, opts) {
        const recentBlockhash = (await this.context.banksClient.getLatestBlockhash())[0];
        const txs = txWithSigners.map((r) => {
            if ("version" in r.tx) {
                const tx = r.tx;
                if (r.signers) {
                    tx.sign(r.signers);
                }
                return tx;
            }
            else {
                const tx = r.tx;
                const signers = r.signers ?? [];
                tx.feePayer = tx.feePayer ?? this.wallet.publicKey;
                tx.recentBlockhash = recentBlockhash;
                signers.forEach((kp) => {
                    tx.partialSign(kp);
                });
                return tx;
            }
        });
        const signedTxs = await this.wallet.signAllTransactions(txs);
        const sigs = [];
        for (let k = 0; k < txs.length; k += 1) {
            const tx = signedTxs[k];
            const rawTx = tx.serialize();
            if ("version" in tx) {
                sigs.push(bs58_1.default.encode(tx.signatures[0]));
            }
            else {
                sigs.push(bs58_1.default.encode(tx.signature));
            }
            await sendWithErr(tx, this.context.banksClient);
        }
        return sigs;
    }
    async simulate(tx, signers, commitment, includeAccounts) {
        if (includeAccounts !== undefined) {
            throw new Error("includeAccounts cannot be used with BankrunProvider");
        }
        if ("version" in tx) {
            signers?.forEach((signer) => tx.sign([signer]));
        }
        else {
            tx.feePayer = tx.feePayer ?? this.wallet.publicKey;
            tx.recentBlockhash = (await this.context.banksClient.getLatestBlockhash())[0];
            signers?.forEach((signer) => tx.partialSign(signer));
        }
        const rawResult = await this.context.banksClient.simulateTransaction(tx, commitment);
        const returnDataRaw = rawResult.meta.returnData;
        const b64 = Buffer.from(returnDataRaw.data).toString("base64");
        const data = [b64, "base64"];
        const returnData = {
            programId: returnDataRaw.programId.toString(),
            data,
        };
        return {
            logs: rawResult.meta.logMessages,
            unitsConsumed: Number(rawResult.meta.computeUnitsConsumed),
            returnData,
        };
    }
}
exports.BankrunProvider = BankrunProvider;
//# sourceMappingURL=index.js.map